# frozen_string_literal: true

module Processors
  class GoogleV2
    include ImageModifiable

    def initialize(id)
      @landscape_request = LandscapeRequest.find(id)
      @landscape = @landscape_request.landscape
    end

    def self.perform(*args)
      new(*args).process
    end

    def process
      # we expect mask validations to be done ealier
      apply_mask_for_transparency

      raise "Image blend not found" unless @landscape_request.reload.full_blend.attached?

      @landscape_request.generating_landscape!
      try_google_request(:generate_initial_landscape)

      @landscape_request.changing_angles!
      try_google_request(:generate_rotated_landscape)

      @landscape_request.generating_drone_view!
      try_google_request(:generate_aerial_landscape)
      @landscape_request.processed!
    rescue StandardError => e
      raise "Google Processor failed with: #{e.message}"
    end

    private

    def try_google_request(method)
      max_retries = 3
      retries = 0

      begin
        save_response(send(method))
      rescue StandardError => e
        Rails.logger.info("GCP failed #{method} with: #{e.message}")
        retries += 1
        raise "Max retries reached for #{method}" if retries > max_retries

        save_response(send(method))
      end
    end

    def generate_initial_landscape
      payload = gcp_payload(initial_landscape_prompt, @landscape_request.full_blend).to_json
      fetch_gcp_response(payload)
    end

    def generate_rotated_landscape
      payload = gcp_payload(rotated_landscape_prompt, @landscape_request.modified_images.last).to_json
      fetch_gcp_response(payload)
    end

    def generate_aerial_landscape
      payload = gcp_payload(aerial_landscape_prompt, @landscape_request.modified_images.first).to_json
      fetch_gcp_response(payload)
    end

    def save_response(response)
      validate_response(response)
      data = response.dig("candidates", 0, "content", "parts", 1, "inlineData")
      save_b64_results(data)
    end

    def validate_response(response)
      return if response.is_a?(Hash)

      image = response.dig("candidates", 0, "content", "parts", 1, "inlineData")
      return if image.present?

      raise "Image is missing in API response"
    end

    def gcp_payload(prompt, image)
      {
        "contents" => [
          {
            "parts" => [
              {
                "text" => prompt

              },
              {
                "inline_data" => {
                  "mime_type" => "image/jpeg",
                  "data" => Base64.strict_encode64(image.download)
                }
              }
            ]
          }
        ]
      }
    end

    def initial_landscape_prompt
      @landscape_request.prompt
    end

    def rotated_landscape_prompt
      "Given this 8k highly detailed image of a landscaped garden compound, move the camera 120% horizontally to view the garden from a different angle.
    Ensure you do not add details that are outside the scope of the house, garden and compound. Return a highly resolution and professional looking angle."
    end

    def aerial_landscape_prompt
      "Given this image design of a well landscaped garden compound, change the perspective an aerial drone view to show the garden landscaping from above.
    Focus on the details of the garden and show the house in the periphery from above. This is an aerial view from a DJI drone perspective."
    end

    def fetch_gcp_response(payload)
      endpoint = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent"

      # Use Faraday to make the API request.
      conn = Faraday.new(
        url: endpoint,
        headers: {
          "Content-Type" => "application/json",
          "x-goog-api-key" => ENV["GEMINI_API_KEY"]
        }
      )

      begin
        response = conn.post("") do |req|
          # Send the JSON payload generated by the gcp_payload method
          req.body = payload
        end

        # Check if the HTTP request was successful (status code 200).
        unless response.status == 200
          Rails.logger.error "GCP request failed with status #{response.status}: #{response.body}"
          raise "API call failed with status #{response.status}"
        end

        JSON.parse(response.body)
      rescue Faraday::Error => e
        Rails.logger.error "Faraday connection error: #{e.message}"
        raise "Failed to connect to GCP API: #{e.message}"
      rescue JSON::ParserError => e
        Rails.logger.error "Failed to parse JSON response: #{e.message}"
        raise "Invalid response from GCP API: #{e.message}"
      end
    end

    def save_b64_results(prediction)
      # predictions.each do |prediction|
      b64_data = prediction["data"]
      return if b64_data.blank?

      img_from_b64 = Base64.decode64(b64_data)
      extension = prediction["mimeType"].split("/").last

      temp_file = Tempfile.new([ "modified_image", ".#{extension}" ], binmode: true)
      temp_file.write(img_from_b64)
      temp_file.rewind

      blob = ActiveStorage::Blob.create_and_upload!(
        io: temp_file,
        filename: "modified_image.#{extension}",
        content_type: prediction["mimeType"]
      )
      @landscape_request.modified_images.attach(blob)
      @landscape_request.save!
      # end
    end

    def apply_mask_for_transparency
      original_image_data = @landscape.original_image.variant(:to_process).processed
      original_image = MiniMagick::Image.read(original_image_data.blob.download)

      mask_binary = @landscape_request.mask.download
      mask_image = MiniMagick::Image.read(mask_binary)

      unless original_image.dimensions == mask_image.dimensions
        mask_image.resize "#{original_image.width}x#{original_image.height}!"
      end

      save_full_blend(mask_image, original_image)
      @landscape_request.save!
    rescue StandardError => e
      raise "#{__method__} failed with: #{e.message}"
    end

    def save_full_blend(mask_image, original_image)
      mask_image.combine_options do |c|
        c.colorspace("Gray")
        c.threshold("50%")
      end

      mask_image.transparent("white")

      masked_image = original_image.composite(mask_image) do |c|
        c.compose "Over"
      end

      blob = attach_blob(masked_image)

      @landscape_request.full_blend.attach(blob)
    end
  end
end
